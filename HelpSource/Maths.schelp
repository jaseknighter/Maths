class:: Maths
summary:: Function Generator
categories::  UGens>Generators

Description::
Creates a logarithmic to exponential curve function that can be triggered or can oscillate. The function starts at 0, goes to 1, and returns to 0 on each iteration or loop.

The UGen outputs a 2 channel signal. Channel[0] is function and Channel[1] is the trigger at the front edge of the function.

Audio Rate Only!

classmethods::

method::ar

argument::riseDur
Duration of the signal's rise from 0 to 1.

argument::fallDur

Duration of the signal's fall from 1 to 0.

argument::logExp

0 is a logarithmic curve, 1 is an exponential curve. 0.5 is linear.

argument::loop

If 1, the function loops. If 0, the function does not loop.

argument::trig

An input trigger serves two functions: it both triggers the function loop to start over, if the function is looping, and will trigger the function to happen once if it is not looping.


Examples::

MouseX and MouseY control the rise and fall durations of the function. MouseButton triggers the function to start over:
code::
a = {LFTri.ar(100+(1000*Maths.ar(MouseX.kr, MouseY.kr, 0.2, 1, MouseButton.kr(lag:0.001))[0]), 0, 0.1)}.play //notice how I am taking the [0]th channel of the Maths and ignoring the [1]st channel.
::

The same thing but with no looping, just MouseButton triggers:
code::
a = {LFTri.ar(100+(1000*Maths.ar(MouseX.kr, MouseY.kr, 0.2, 0, MouseButton.kr(lag:0.001))[0]), 0, 0.1)}.play
::

Changing the shape of the envelope from Log to Exponential has significant influence over the sound:
code::
a = {LFTri.ar(100+(1000*Maths.ar(MouseX.kr, MouseY.kr, SinOsc.ar(0.2, 0).range(0,1), 1, MouseButton.kr(lag:0.001))[0]), 0, 0.1)}.play //notice how I am taking the [0]th channel of the Maths and ignoring the [1]st channel.
::

A Maths can also be used to trigger a Maths. Here we have a complex percussion sound made by using the trigger out of one Maths to trigger a second, nonlooping Maths.
code::
(
a = {
	var sig, mathsA, trig, mathsB, sig1, noise;

	#mathsA, trig = Maths.ar(0.001, MouseX.kr, 0.9, 1, MouseButton.kr(0,1, 0.001));  //using both the function and the trigger outputs
	sig = LFTri.ar(100+(2000*mathsA), 0, 0.1);
	mathsB = Maths.ar(0.001, min(0.1, MouseX.kr), 0.9, 0, trig)[0];
	noise = mathsB*WhiteNoise.ar(0.1);

	sig1 = LFTri.ar(20+(mathsB*1400), 0, 0.1);

	(sig+sig1+noise).dup
}.play

)
::

Rise and Fall can each be up to 100 seconds:
code::
a = {LFTri.ar(50+(1000*Maths.ar(10, 10, 0.5, 1)[0]), 0, 0.1)}.play //notice how I am taking the [0]th channel of the Maths and ignoring the [1]st channel.
::

